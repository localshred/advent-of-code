def convert_input(input)
  input
    .split(/[\r\n]+/)
    .map { |line| line.strip.chars }
    .select { |line| !line.empty? }
end

PUZZLE = convert_input(<<~INPUT)
LDUDDRUDRRURRRRDRUUDULDLULRRLLLUDDULRDLDDLRULLDDLRUURRLDUDDDDLUULUUDDDDLLLLLULLRURDRLRLRLLURDLLDDUULUUUUDLULLRLUUDDLRDRRURRLURRLLLRRDLRUDURRLRRRLULRDLUDRDRLUDDUUULDDDDDURLDULLRDDRRUDDDDRRURRULUDDLLRRDRURDLLLLLUUUDLULURLULLDRLRRDDLUDURUDRLRURURLRRDDLDUULURULRRLLLDRURDULRDUURRRLDLDUDDRLURRDRDRRLDLRRRLRURDRLDRUDLURRUURDLDRULULURRLDLLLUURRULUDDDRLDDUDDDRRLRDUDRUUDDULRDDULDDURULUDLUDRUDDDLRRRRRDLULDRLRRRRUULDUUDRRLURDLLUUDUDDDLUUURDRUULRURULRLLDDLLUDLURRLDRLDDDLULULLURLULRDLDRDDDLRDUDUURUUULDLLRDRUDRDURUUDDLRRRRLLLUULURRURLLDDLDDD
DRURURLLUURRRULURRLRULLLURDULRLRRRLRUURRLRRURRRRUURRRLUDRDUDLUUDULURRLDLULURRLDURLUUDLDUDRUURDDRDLLLDDRDDLUUDRDUDDRRDLDUDRLDDDRLLDDLUDRULRLLURLDLURRDRUDUDLDLULLLRDLLRRDULLDRURRDLDRURDURDULUUURURDLUDRRURLRRLDULRRDURRDRDDULLDRRRLDRRURRRRUURDRLLLRRULLUDUDRRDDRURLULLUUDDRLDRRDUDLULUUDRDDDDLRLRULRLRLLDLLRRDDLDRDURRULLRLRRLULRULDDDRDRULDRUUDURDLLRDRURDRLRDDUDLLRUDLURURRULLUDRDRDURLLLDDDRDRURRDDRLRRRDLLDDLDURUULURULRLULRLLURLUDULDRRDDLRDLRRLRLLULLDDDRDRU
URUUDUDRDDRDRRRDLLUDRUDRUUUURDRRDUDUULDUDLLUDRRUDLLRDLLULULDRRDDULDRLDLDDULLDDRDDDLRLLDLLRDUUDUURLUDURDRRRRLRRLDRRUULLDLDLRDURULRURULRRDRRDDUUURDURLLDDUUDLRLDURULURRRDRRUUUDRDDLRLRRLLULUDDRRLRRRRLRDRUDDUULULRRURUURURRLRUDLRRUUURUULLULULRRDDULDRRLLLDLUDRRRLLRDLLRLDUDDRRULULUDLURLDRDRRLULLRRDRDLUURLDDURRLDRLURULDLDRDLURRDRLUUDRUULLDRDURLLDLRUDDULLLLDLDDDLURDDUDUDDRLRDDUDDURURLULLRLUDRDDUDDLDRUURLDLUUURDUULRULLDDDURULDDLLD
LRRLLRURUURRDLURRULDDDLURDUURLLDLRRRRULUUDDLULLDLLRDLUDUULLUDRLLDRULDDURURDUUULRUDRLLRDDDURLRDRRURDDRUDDRRULULLLDLRLULLDLLDRLLLUDLRURLDULRDDRDLDRRDLUUDDLURDLURLUDLRDLDUURLRRUULDLURULUURULLURLDDURRURDRLUULLRRLLLDDDURLURUURLLLLDLLLUDLDLRDULUULRRLUUUUDLURRURRULULULRURDDRRRRDRUDRURDUDDDDUDLURURRDRRDRUDRLDLDDDLURRRURRUDLDURDRLDLDLDDUDURLUDUUDRULLRLLUUDDUURRRUDURDRRUURLUDRRUDLUDDRUUDLULDLLDLRUUDUULLDULRRLDRUDRRDRLUUDDRUDDLLULRLULLDLDUULLDRUUDDUDLLLLDLDDLDLURLDLRUUDDUULLUDUUDRUDLRDDRDLDRUUDUDLLDUURRRLLLLRLLRLLRLUUDULLRLURDLLRUUDRULLULRDRDRRULRDLUDDURRRRURLLRDRLLDRUUULDUDDLRDRD
DDLRRULRDURDURULLLLRLDDRDDRLLURLRDLULUDURRLUDLDUDRDULDDULURDRURLLDRRLDURRLUULLRUUDUUDLDDLRUUDRRDDRLURDRUDRRRDRUUDDRLLUURLURUDLLRRDRDLUUDLUDURUUDDUULUURLUDLLDDULLUURDDRDLLDRLLDDDRRDLDULLURRLDLRRRLRRURUUDRLURURUULDURUDRRLUDUDLRUDDUDDRLLLULUDULRURDRLUURRRRDLLRDRURRRUURULRUDULDULULUULULLURDUDUDRLDULDRDDULRULDLURLRLDDDDDDULDRURRRRDLLRUDDRDDLUUDUDDRLLRLDLUDRUDULDDDRLLLLURURLDLUUULRRRUDLLULUUULLDLRLDLLRLRDLDULLRLUDDDRDRDDLULUUR
INPUT

TESTS = [
  [
    convert_input(%q{
      ULL
      RRDDD
      LURDL
      UUUUD
    }),
    "1985"
  ]
]

START_KEY = 5

# x, y
COORDINATES_TO_KEY = {}
COORDINATES_TO_KEY[[0, 0]] = 1
COORDINATES_TO_KEY[[1, 0]] = 2
COORDINATES_TO_KEY[[2, 0]] = 3
COORDINATES_TO_KEY[[0, 1]] = 4
COORDINATES_TO_KEY[[1, 1]] = 5
COORDINATES_TO_KEY[[2, 1]] = 6
COORDINATES_TO_KEY[[0, 2]] = 7
COORDINATES_TO_KEY[[1, 2]] = 8
COORDINATES_TO_KEY[[2, 2]] = 9

KEY_TO_COORDINATES = COORDINATES_TO_KEY.invert

MIN_COORD = 0
MAX_COORD = 2

def up((x, y))
  [x, [y - 1, MIN_COORD].max]
end

def down((x, y))
  [x, [y + 1, MAX_COORD].min]
end

def left((x, y))
  [[x - 1, MIN_COORD].max, y]
end

def right((x, y))
  [[x + 1, MAX_COORD].min, y]
end

def move(coordinates, direction)
  case direction
  when "U" then up(coordinates)
  when "D" then down(coordinates)
  when "L" then left(coordinates)
  when "R" then right(coordinates)
  else raise "Got something weird #{direction}"
  end
end

def derive_codes(accumulator, instructions)
  codes = accumulator[:codes]
  last_key = accumulator[:last_key]
  start_coordinates = KEY_TO_COORDINATES[last_key]
  end_coordinates = instructions.reduce(start_coordinates, &method(:move))
  code = COORDINATES_TO_KEY[end_coordinates]
  { codes: codes.concat([ code ]), last_key: code }
end

def solve(input)
  initial = { codes: [], last_key: START_KEY }
  result = input.reduce(initial, &method(:derive_codes))
  result[:codes].join
end

def test(label, input, expected)
  instruction_count = input.reduce(0) { |sum, line| sum += line.size }
  $stdout.write "[#{label}]: Expected #{instruction_count} instructions to return code #{expected.strip}"
  actual = solve(input)
  $stdout.write ", got #{actual.inspect}"
  if actual == expected
    $stdout.write " âœ…"
  else
    $stdout.write " ğŸ’¥"
  end
  puts
end

def run
  TESTS.each_with_index do |(input, expected), index|
    test("Test #{index}", input, expected)
  end
  puts "[Puzzle]: #{solve(PUZZLE)}"
end

run
