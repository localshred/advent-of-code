def convert_input(input)
  input
    .split(/[\r\n]+/)
    .map { |line| line.strip.chars }
    .select { |line| !line.empty? }
end

PUZZLE = convert_input(<<~INPUT)
LDUDDRUDRRURRRRDRUUDULDLULRRLLLUDDULRDLDDLRULLDDLRUURRLDUDDDDLUULUUDDDDLLLLLULLRURDRLRLRLLURDLLDDUULUUUUDLULLRLUUDDLRDRRURRLURRLLLRRDLRUDURRLRRRLULRDLUDRDRLUDDUUULDDDDDURLDULLRDDRRUDDDDRRURRULUDDLLRRDRURDLLLLLUUUDLULURLULLDRLRRDDLUDURUDRLRURURLRRDDLDUULURULRRLLLDRURDULRDUURRRLDLDUDDRLURRDRDRRLDLRRRLRURDRLDRUDLURRUURDLDRULULURRLDLLLUURRULUDDDRLDDUDDDRRLRDUDRUUDDULRDDULDDURULUDLUDRUDDDLRRRRRDLULDRLRRRRUULDUUDRRLURDLLUUDUDDDLUUURDRUULRURULRLLDDLLUDLURRLDRLDDDLULULLURLULRDLDRDDDLRDUDUURUUULDLLRDRUDRDURUUDDLRRRRLLLUULURRURLLDDLDDD
DRURURLLUURRRULURRLRULLLURDULRLRRRLRUURRLRRURRRRUURRRLUDRDUDLUUDULURRLDLULURRLDURLUUDLDUDRUURDDRDLLLDDRDDLUUDRDUDDRRDLDUDRLDDDRLLDDLUDRULRLLURLDLURRDRUDUDLDLULLLRDLLRRDULLDRURRDLDRURDURDULUUURURDLUDRRURLRRLDULRRDURRDRDDULLDRRRLDRRURRRRUURDRLLLRRULLUDUDRRDDRURLULLUUDDRLDRRDUDLULUUDRDDDDLRLRULRLRLLDLLRRDDLDRDURRULLRLRRLULRULDDDRDRULDRUUDURDLLRDRURDRLRDDUDLLRUDLURURRULLUDRDRDURLLLDDDRDRURRDDRLRRRDLLDDLDURUULURULRLULRLLURLUDULDRRDDLRDLRRLRLLULLDDDRDRU
URUUDUDRDDRDRRRDLLUDRUDRUUUURDRRDUDUULDUDLLUDRRUDLLRDLLULULDRRDDULDRLDLDDULLDDRDDDLRLLDLLRDUUDUURLUDURDRRRRLRRLDRRUULLDLDLRDURULRURULRRDRRDDUUURDURLLDDUUDLRLDURULURRRDRRUUUDRDDLRLRRLLULUDDRRLRRRRLRDRUDDUULULRRURUURURRLRUDLRRUUURUULLULULRRDDULDRRLLLDLUDRRRLLRDLLRLDUDDRRULULUDLURLDRDRRLULLRRDRDLUURLDDURRLDRLURULDLDRDLURRDRLUUDRUULLDRDURLLDLRUDDULLLLDLDDDLURDDUDUDDRLRDDUDDURURLULLRLUDRDDUDDLDRUURLDLUUURDUULRULLDDDURULDDLLD
LRRLLRURUURRDLURRULDDDLURDUURLLDLRRRRULUUDDLULLDLLRDLUDUULLUDRLLDRULDDURURDUUULRUDRLLRDDDURLRDRRURDDRUDDRRULULLLDLRLULLDLLDRLLLUDLRURLDULRDDRDLDRRDLUUDDLURDLURLUDLRDLDUURLRRUULDLURULUURULLURLDDURRURDRLUULLRRLLLDDDURLURUURLLLLDLLLUDLDLRDULUULRRLUUUUDLURRURRULULULRURDDRRRRDRUDRURDUDDDDUDLURURRDRRDRUDRLDLDDDLURRRURRUDLDURDRLDLDLDDUDURLUDUUDRULLRLLUUDDUURRRUDURDRRUURLUDRRUDLUDDRUUDLULDLLDLRUUDUULLDULRRLDRUDRRDRLUUDDRUDDLLULRLULLDLDUULLDRUUDDUDLLLLDLDDLDLURLDLRUUDDUULLUDUUDRUDLRDDRDLDRUUDUDLLDUURRRLLLLRLLRLLRLUUDULLRLURDLLRUUDRULLULRDRDRRULRDLUDDURRRRURLLRDRLLDRUUULDUDDLRDRD
DDLRRULRDURDURULLLLRLDDRDDRLLURLRDLULUDURRLUDLDUDRDULDDULURDRURLLDRRLDURRLUULLRUUDUUDLDDLRUUDRRDDRLURDRUDRRRDRUUDDRLLUURLURUDLLRRDRDLUUDLUDURUUDDUULUURLUDLLDDULLUURDDRDLLDRLLDDDRRDLDULLURRLDLRRRLRRURUUDRLURURUULDURUDRRLUDUDLRUDDUDDRLLLULUDULRURDRLUURRRRDLLRDRURRRUURULRUDULDULULUULULLURDUDUDRLDULDRDDULRULDLURLRLDDDDDDULDRURRRRDLLRUDDRDDLUUDUDDRLLRLDLUDRUDULDDDRLLLLURURLDLUUULRRRUDLLULUUULLDLRLDLLRLRDLDULLRLUDDDRDRDDLULUUR
INPUT

TESTS = [
  [
    convert_input(%q{
      ULL
      RRDDD
      LURDL
      UUUUD
    }),
    "5DB3"
  ]
]

START_KEY = 5

# Numpad: Blank spaces are non-buttons
#
#   ___________
#   |    1    |
#   |  2 3 4  |
#   |5 6 7 8 9|
#   |  A B C  |
#   |____D____|
#
# x, y
COORDINATES_TO_KEY = {}

# Row 1
COORDINATES_TO_KEY[[0, 0]] = nil
COORDINATES_TO_KEY[[1, 0]] = nil
COORDINATES_TO_KEY[[2, 0]] = 1
COORDINATES_TO_KEY[[3, 0]] = nil
COORDINATES_TO_KEY[[4, 0]] = nil

# Row 2
COORDINATES_TO_KEY[[0, 1]] = nil
COORDINATES_TO_KEY[[1, 1]] = 2
COORDINATES_TO_KEY[[2, 1]] = 3
COORDINATES_TO_KEY[[3, 1]] = 4
COORDINATES_TO_KEY[[4, 1]] = nil

# Row 3
COORDINATES_TO_KEY[[0, 2]] = 5
COORDINATES_TO_KEY[[1, 2]] = 6
COORDINATES_TO_KEY[[2, 2]] = 7
COORDINATES_TO_KEY[[3, 2]] = 8
COORDINATES_TO_KEY[[4, 2]] = 9

# Row 4
COORDINATES_TO_KEY[[0, 3]] = nil
COORDINATES_TO_KEY[[1, 3]] = "A"
COORDINATES_TO_KEY[[2, 3]] = "B"
COORDINATES_TO_KEY[[3, 3]] = "C"
COORDINATES_TO_KEY[[4, 3]] = nil

# Row 5
COORDINATES_TO_KEY[[0, 4]] = nil
COORDINATES_TO_KEY[[1, 4]] = nil
COORDINATES_TO_KEY[[2, 4]] = "D"
COORDINATES_TO_KEY[[3, 4]] = nil
COORDINATES_TO_KEY[[4, 4]] = nil

KEY_TO_COORDINATES = COORDINATES_TO_KEY.invert
KEY_TO_COORDINATES.delete(nil)

MIN_COORDS = {
  0 => 2,
  1 => 1,
  2 => 0,
  3 => 1,
  4 => 2,
}

MAX_COORDS = {
  0 => 2,
  1 => 3,
  2 => 4,
  3 => 3,
  4 => 2,
}

def up((x, y))
  [x, [y - 1, MIN_COORDS[x]].max]
end

def down((x, y))
  [x, [y + 1, MAX_COORDS[x]].min]
end

def left((x, y))
  [[x - 1, MIN_COORDS[y]].max, y]
end

def right((x, y))
  [[x + 1, MAX_COORDS[y]].min, y]
end

def move(coordinates, direction)
  case direction
  when "U" then up(coordinates)
  when "D" then down(coordinates)
  when "L" then left(coordinates)
  when "R" then right(coordinates)
  else raise "Got something weird #{direction}"
  end
end

def derive_codes(accumulator, instructions)
  codes = accumulator[:codes]
  last_key = accumulator[:last_key]
  start_coordinates = KEY_TO_COORDINATES[last_key]
  end_coordinates = instructions.reduce(start_coordinates, &method(:move))
  code = COORDINATES_TO_KEY[end_coordinates]
  { codes: codes.concat([ code ]), last_key: code }
end

def solve(input)
  initial = { codes: [], last_key: START_KEY }
  result = input.reduce(initial, &method(:derive_codes))
  result[:codes].join
end

def test(label, input, expected)
  instruction_count = input.reduce(0) { |sum, line| sum += line.size }
  $stdout.write "[#{label}]: Expected #{instruction_count} instructions to return code #{expected.strip}"
  actual = solve(input)
  $stdout.write ", got #{actual.inspect}"
  if actual == expected
    $stdout.write " âœ…"
  else
    $stdout.write " ðŸ’¥"
  end
  puts
end

def run
  TESTS.each_with_index do |(input, expected), index|
    test("Test #{index}", input, expected)
  end
  puts "[Puzzle]: #{solve(PUZZLE)}"
end

run
